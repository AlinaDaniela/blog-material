A colleague of mine recently had the task to implement a design that incorporated radial progress bars. The design was brilliant and the implementation worked (he used geedmos solution), and so he moved on to implementing the rest of the design. Somehow my thoughts got stuck with that progress indicator and I thought to myself “surely, you can make that indicator spin, maybe even with CSS transitions”. So I stubbornly set out to figure out how to do this.

My research on the net left me wanting, nobody really solved it.
Yes, Jeff Pihach made a “radial progress bar”, but he uses CSS animations rather than CSS transitions. They cannot be controlled (except paused and resumed) and you have therefore no way to set the progress to e.g. 23%.
There are jQuery plugins which can do it for you, but they use Javascript — CSS will always have the upper hand performance-wise when it comes to animations, especially on mobile devices.
This is why I set out to implement my own CSS-animated radial progress bar.

Although the title of this post states that the progress indicator is made with CSS, we will actually use less.
The advantages are manifold; primarily we use it because it will be easier to show the calculations used to position elements (later on we will also use it to create some nifty [data-progress=”@{progress}”] selectors).

The Basics To create an animated radial progress indicator, one first has to be able to create an animated circle — a pie chart that can animate from 0% to 100% if you will.





Let’s begin with a simple div-element rotation

We have our html:

<div class="radial-progress">
  <div class="circle">
    <div class="fill"></div>
  </div>
</div>

“radial-progress” will be our root while “circle” will contain anything pertaining to the circle/pie chart we intend to draw.

Colors & Size “radial-progress” should have a background-color while “fill” should have a color as well.

.radial-progress {
  @circle-background: #d6dadc;
  @circle-color: #97a71d;
  background-color: @circle-background;
  .circle .fill {
    background-color: @circle-color;
  }
}

The entire thing should also have a size:

.radial-progress {
  @circle-size: 120px;
  width: @circle-size;
  height: @circle-size;
  .circle .fill {
    width: @circle-size;
    height: @circle-size;
  }
}

Rotation To rotate the “fill” we preliminarily use some Javascript to set the “transform: rotate()” style.

var transform_styles = ['-webkit-transform',
                        '-ms-transform',
                        'transform'];
window.randomize = function() {
 var rotation = Math.floor(Math.random() * 360);
 for(i in transform_styles) {
  $('.circle .fill').css(transform_styles[i],
                         'rotate(' + rotation + 'deg)');
 }
}

The “random” behavior is used for demonstration purposes. Not however how we make the “fill” element turn a full 360º. For the time being we will think of 360º as 100% and e.g. 90º as 25%.

The rotation animation is of course the one we want to animate, so lets add a transition length variable and the css property to “fill”:

.radial-progress {
  @transition-length: 1s;
  .circle .fill {
    transition: -webkit-transform @transition-length;
    transition: -ms-transform @transition-length;
    transition: transform @transition-length;
  }
}

Clipping Rotating a full circle is no fun. That is why we begin with a half-circle. To do that, we use the CSS clip property. It allows us to make only a specific area of an element visible.

Let’s show only the left half of the circle.

.radial-progress {
  .circle .fill {
    position: absolute;
    /* rect(<top>, <right>, <bottom>, <left>) */
    clip: rect(0px, @circle-size/2, @circle-size, 0px);
  }
}

We also set the “fill” position to “absolute”, since “clip” will only work on elements positioned that way.

Smoothing the Edges If you are using Chrome, you will very likely see jagged edges when our div is rotated.

Jagged edges in Chrome, when rotating elements.You can avoid this issue by setting the CSS property “-webkit-backface-visibility” to “hidden”.

.radial-progress {
 .circle .fill {
   -webkit-backface-visibility: hidden;
  }
}

You can view the intermediate jsfiddle result of all this before we continue with the next part.

That’s no Circle?! No, it’s not, great observational skills there ☺
Let’s make it one then! All we need to do is set the border radius to 50%.

.radial-progress {
  border-radius: 50%;
  .circle .fill {
    border-radius: 50%;
  }
}

Setting border-radius to 50% on an element makes it a circle.Masks Remember how we decided that 90º rotation should be 25% etc.? We can get closer to that representation by hiding the “fill” when it is in the left half of the circle.

The half-circle is only visible in the left half of the circle.To do that we once again use the “clip” CSS property. This time we put the “fill” inside another element, which itself is clipped, essentially creating a “mask”.

<div class="radial-progress">
  <div class="circle">
    <div class="mask">
      <div class="fill"></div>
    </div>
  </div>
</div>

The mask has the same CSS properties as “fill”, with the transition and background-color properties being the exception. Since we only want to show the half-circle on the right side of the circle, we mirror the clipping rectangle of the half-circle:

.radial-progress {
  .circle {
    .mask {
      /* rect(<top>, <right>, <bottom>, <left>) */
      clip: rect(0px,@circle-size,@circle-size,@circle-size/2);
    .fill {
      clip: rect(0px,@circle-size/2,@circle-size,0px);
    }
  }
}

I recommend fiddling with the clipping areas to get a feel for how they work.

Two Halfs to a Circle Note how in the previous part the circle moved into the left half again once it passed 180º.

Half circle disappearing behind the maskWe should limit it to only move 180º and consider that 100%.

window.randomize = function() {
  var rotation = Math.floor(Math.random() * 180);
  var fill_rotation = rotation / 2;
  for(i in transform_styles) {
    $('.circle .fill').css(transform_styles[i],
                           'rotate(' + fill_rotation + 'deg)');
  }
}

That change will however leave us with only half a radial progress bar. So let’s add another half-circle, what could possibly go wrong?!





We want the second half-circle to occupy the left half of the circle. As we saw previously, mirroring a clipping rectangle is quite easy.
First, the markup:

<div class="radial-progress">
  <div class="circle">
    <div class="mask left">
      <div class="fill"></div>
    </div>
    <div class="mask right">
      <div class="fill"></div>
    </div>
  </div>
</div>

The clipping:

.mask.left {
  /* rect(<top>, <right>, <bottom>, <left>) */
  clip: rect(0px, @circle-size, @circle-size, @circle-size/2);
  .fill {
    clip: rect(0px, @circle-size/2, @circle-size, 0px);
  }
}
.mask.right {
  clip: rect(0px, @circle-size/2, @circle-size, 0px);
  .fill {
    clip: rect(0px, @circle-size, @circle-size, @circle-size/2);
  }
}

This is the result:

Clipping to half-circles on either side of a full circleAlright! We’re getting somewhere, but it is still not really a pie-chart. The second half-circle is always starting at 6 o’clock.

The area filled by the two half-circles however is now representative of a full 100% when we set the rotation of each half-circle to 180º each.

Have a look at it on jsFiddle.

Stitching It Together What we really want is the left half-circle to start where the right one ends. Recall how the both half-circles are children of masks:

<div class="radial-progress">
  <div class="circle">
    <div class="mask left">
      <div class="fill"></div>
    </div>
    <div class="mask right">
      <div class="fill"></div>
    </div>
  </div>
</div>

To put the left half-circle next to the right one, we need rotate the left half-circle mask accordingly. In other words: If we can get the visible area of “.mask.left” to begin where the visible area of “.mask.right fill” ends, we are done.

In a static context of 0º (or 0%) this is easily achieved by setting the clipping rectangle of the left mask to be the same as the right mask. That would however fully reveal the left half-circle, so we put that on the opposite side. This means that our two masks and half-circles are clipped exactly the same.

.mask {
  /* rect(<top>, <right>, <bottom>, <left>) */
  clip: rect(0px, @circle-size, @circle-size, @circle-size/2);
  .fill {
    clip: rect(0px, @circle-size/2, @circle-size, 0px);
  }
}

At this point we would see two overlapping half-circles filling up until 180º, if we were to rotate normally. The goal is to have the left half circle begin where the right one ends, so lets just rotate the mask for the left half circle by the same amount! This way the left mask will begin exactly where the right half-circle ends.





When rotating the mask the “fill” inside will rotate as well, meaning if we rotate the mask 15º and the “fill” inside 15º the half-circle will actually have rotated 30º.

The Javascript adjustment is fairly simple.

$('.circle .fill, .circle .mask.full').css(transform_styles[i], 'rotate(' + fill_rotation + 'deg)');

Now the left half-circle rotates a full 360º for 100%, while the right half-circle only rotates 180º. Keeping that in mind, let us rename the half-circles to “half-spin” and “full-spin”.

Stitching two half circles together to form a full circleHave a look at the jsFiddle for this. Surprisingly, this change removes lines from the CSS, because we can handle the clipping of the masks and half-circles in the same way.

Mind the Gap The gap between two clipped and rotated elements that are positioned right next to each other.Because the browser needs to round to whole pixels you will be able to notice the “seam” between the two half-circles. The best solution I have been able to come up with is adding a third “fill-fix” that rotates together with the two half-circles.

<div class="radial-progress">
  <div class="circle">
    <div class="mask full">
      <div class="fill"></div>
    </div>
    <div class="mask half">
      <div class="fill"></div>
      <div class="fill fix"></div>
    </div>
  </div>
</div>

This “fill-fix” is a child of the static mask. It will sufficiently cover the gap if we set its full rotation to 360º since it is not clipped the same way the full-spin is. At 100% the “fill-fix” will overlap completely with the full-spin and not cover the gap, that specific position is however completely vertical for the clipping edges, so no rounding errors occurs.

The same CSS applies as before, but we will have to adjust our Javascript:

var rotation = Math.floor(Math.random() * 180);
var fill_rotation = rotation;
var fix_rotation = rotation * 2;
for(i in transform_styles) {
  $('.circle .fill, .circle .mask.full').css(transform_styles[i],
                 'rotate(' + fill_rotation + 'deg)');
  $('.circle .fill.fix').css(transform_styles[i],
                             'rotate(' + fix_rotation + 'deg)');
 }

Two half-circles stitched together and their “seam” hidden by a third elementCheck out the jsFiddle. You should no longer be able to see any gap.

Prettifying Now that we have a circle/pie-chart that can animate from 0º all the way to 360º seamlessly, we can begin building on that.

Inset First, let’s add an inset. This will make our circle look more like an actual radial progress indicator

<div class="radial-progress">
  <div class="circle">
    <div class="mask full">
      <div class="fill"></div>
    </div>
    <div class="mask half">
      <div class="fill"></div>
      <div class="fill fix"></div>
    </div>
  </div>
  <div class="inset"></div>
</div> 

Have some less variables to wash that DOM down with:

.radial-progress {
  @inset-size: 90px;
  @inset-color: #fbfbfb;
}

The inset should of course be round and positioned in the middle of our circle. We position it by using a few less calculations:

.radial-progress {
  .inset {
    width: @inset-size;
    height: @inset-size;
    position: absolute;
    margin-left: (@circle-size - @inset-size)/2;
    margin-top: (@circle-size - @inset-size)/2;
    background-color: @inset-color;
    border-radius: 50%;
  }
}

Shadow Shadows look nice, so let’s add one to both the inset and the circle border.

.radial-progress {
  box-shadow: @shadow-size @shadow-size @shadow-blur @shadow-color inset;
  .inset {
    box-shadow: @shadow-size @shadow-size @shadow-blur @shadow-color;
  }
}

To avoid hardcoding any shadow positions in pixels, we use a few variables.

.radial-progress {
  @circle-thickness: (@circle-size - @inset-size) / 2;
  @shadow-size: @circle-thickness * .2;
  @shadow-blur: @circle-thickness * .35;
  @shadow-color: rgba(0,0,0,0.2);
}

Radial progress indicator with shadowVery pretty indeed! Take a look at the jsFiddle for this part, if you want to play with the inset or shadow settings.

Less is More Having to adjust of two jQuery selections with different rotation values is cumbersome and error prone. Wouldn’t it be nicer if we could just call

$('.radial-progress').attr('data-progress', Math.floor(Math.random() * 100));

and be done with it?
If we want to do that, we have to define every selector from from [data-progress=”%0”] to [data-progress=”%100”] and set the rotations accordingly. Luckily less can loop using recursive calls.

.radial-progress {
  @i: 0;
  .loop (@i) when (@i <= 100) {
    &[data-progress="@{i}"] {
      .circle { }
    }
    .loop(@i + 1);
  }
  .loop(@i);
}

All we need to do is fill in the blanks. The first order of business is figuring out how many degrees correspond to 1%:

.radial-progress {
  @increment: 180deg / 100;
}

The Javascript we used corresponds to the same transform css property with a little math added.

&[data-progress="@{i}"] {
  .circle {
    .mask.full, .fill {
      -webkit-transform: rotate(@increment * @i);
      -ms-transform: rotate(@increment * @i);
      transform: rotate(@increment * @i);
    } 
    .fill.fix {
      -webkit-transform: rotate(@increment * @i * 2);
      -ms-transform: rotate(@increment * @i * 2);
      transform: rotate(@increment * @i * 2);
    }
  }
}

The result is the same as before, but you now have an easy way to adjust the percentage of your radial progress indicator.

But How Much is That? Indeed. Up until now we have only shown the progress graphically, but we will need a percentage to properly indicate how far we have gotten.

We use the inset as a container for the percentage element.

<div class="radial-progress" data-progress="0">
  <div class="circle">
    <div class="mask full">
      <div class="fill"></div>
    </div>
    <div class="mask half">
      <div class="fill"></div>
      <div class="fill fix"></div>
    </div>
  </div>
  <div class="inset">
    <div class="percentage"></div>
  </div>
</div>

Since we already have selectors that match the given percentages, we might as well keep using them and insert the percentage using CSS.

.radial-progress {
  &[data-progress="@{i}"] {
    .inset .percentage:before {
      content: "@{i}%"
    }
  }
}

To properly position the percentage smack in the center of the inset, we introduce some variables that we can use for calculations later on.

.radial-progress {
  @percentage-color: #97a71d;
  @percentage-font-size: 22px;
  @percentage-text-width: 44px;
  @percentage-line-height: @percentage-font-size - 4px;
}

And a nice font.

@import url(http://fonts.googleapis.com/css?family=Lato:100,300,400,700,900,100italic,300italic,400italic,700italic,900italic);

The CSS properties are rather straightforward, note how we position the element vertically by using half the difference between the inset height and the text line-height.

.radial-progress {
  .inset .percentage {
    width: @percentage-text-width;
    position: absolute;
    top: (@inset-size - @percentage-line-height) / 2;
    left: (@inset-size - @percentage-text-width) / 2;

    line-height: @percentage-line-height;
    text-align: center;

    font-family: "Lato", "Helvetica Neue", Helvetica, Arial, sans-serif;
    color: @percentage-color;
    font-weight: 800;
    font-size: @percentage-font-size;
  }
}

Radial progress indicator with percentage textHere is the resulting jsFiddle.

Animate All the Things! The result is splendid (if I may say so myself). But we can go even further: Why should the percentage text not be animated as well?! It shouldn’t be a slider that simply moves the next number into place, but rather a quick switch from one number to the next.





This is where CSS gets complicated. Its transformations were built for smooth animations between two states and not abrupt switches, so how can we achieve with CSS animations exactly what they are trying to avoid?
Linebreaks.

Linebreaks move entire elements onto the next line once there is no space for them on the current one. We can abuse that behavior to animate our percentages. All we need is an element with all our numbers on one line, a mask that only shows the first number on the next line, and an animation that shrinks the element width depending on the percentage set.

This means that the percentage that corresponds with the circle size will always be the first number on the second line during animation.

First we adjust the markup to contain all numbers from 0%-100% inside the percentage element.

<div class="radial-progress" data-progress="0">
  <div class="circle">
    <div class="mask full">
      <div class="fill"></div>
    </div>
    <div class="mask half">
      <div class="fill"></div>
      <div class="fill fix"></div>
    </div>
  </div>
  <div class="inset">
    <div class="percentage">
      <span></span><span>0%</span><span>1%</span><span>2%</span><span>3%</span>...<span>99%</span><span>100%</span>
    </div>
  </div>
</div>

The first empty <span> is necessary so we can get 0% to jump to the second line as well.

We will need to move the percentage element one line-height up to have the second line be in the center of the inset. Also, we only want to show that second line (and only the first number), so we use the good old clip property for that. Lastly we want to animate width changes now.

.radial-progress {
  .inset .percentage {
    top: (@inset-size - @percentage-line-height) / 2 - @percentage-line-height;
    /* rect(<top>, <right>, <bottom>, <left>) */
    clip: rect(@percentage-line-height, @percentage-text-width, @percentage-line-height + @percentage-line-height, 0px);
    transition: width @transition-length;
  }
}

The number elements inside “percentage” should be center and have the same width to ensure that each number jumps to the next line at the right time.

.radial-progress {
  .inset .percentage {
    span {
      width: @percentage-text-width;
      display: inline-block;
      text-align: center;
    }
  }
}

A simple change in our data-progress selector makes sure that the width on the percentage element changes proportionally to the percentage set on the root.

.radial-progress {
  &[data-progress="@{i}"] {
    .inset .percentage {
      width: @i * @percentage-text-width + @percentage-text-width;
    }
  }
}

And that’s it! The numbers are now whooshing by when progress is made.

Check out the jsFiddle to see how it works. You might want to turn off the .percentage clipping rectangle to see exactly how things work.

Going further easing functions, duration, colors depending on percentage, split up into more than two circles or get a linear gradient, adjust inset size etc. (examples)
